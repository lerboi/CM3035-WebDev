================================================================================
NETFLIX DATASET - DATABASE MODEL DESIGN
Step 1.2: Plan Database Models
================================================================================

PROJECT: CM3035 Advanced Web Development Coursework
DATASET: Netflix Movies and TV Shows (8,810 entries)
DATE: December 14, 2024

================================================================================
MODEL DESIGN DECISION: SINGLE MODEL APPROACH (RECOMMENDED)
================================================================================

RATIONALE:
----------
After analyzing the dataset structure and project requirements, I recommend
using a SINGLE MODEL approach for the following reasons:

✅ PROS:
- Simpler implementation (faster development)
- Direct 1:1 mapping with CSV structure (easier data loading)
- Sufficient for demonstrating complex queries
- Meets all coursework requirements (R1, R2, R3)
- Easier to test and debug
- Faster query performance for most use cases
- Less migration complexity

✅ REQUIREMENTS MET:
- R1a: Demonstrates models and migrations ✓
- R2: Appropriate data model for the data ✓
- Can still show validators, serializers, complex queries ✓

⚠️ CONSIDERATION:
- Doesn't demonstrate ForeignKey/ManyToMany relationships
- BUT: Can still score full marks with well-designed single model
- Can always refactor to multiple models later if time permits

ALTERNATIVE: Multiple models with relationships (see section below)

================================================================================
PRIMARY MODEL: NetflixTitle
================================================================================

MODEL NAME: NetflixTitle
TABLE NAME: api_netflixtitle (auto-generated by Django)
PURPOSE: Store all Netflix movies and TV shows with their metadata

FIELDS DEFINITION:
------------------

1. show_id
   --------
   Django Field: CharField(max_length=20, unique=True, primary_key=True)
   Database Type: VARCHAR(20) PRIMARY KEY
   Description: Unique identifier for each Netflix title
   Example Values: "s1", "s2", "s8807"
   Constraints: 
   - NOT NULL (required)
   - UNIQUE (enforced by primary_key=True)
   - PRIMARY KEY
   Validators: None needed (always provided in dataset)
   Notes: Using this as primary key instead of auto-generated id

2. type
   ----
   Django Field: CharField(max_length=20, choices=TYPE_CHOICES)
   Database Type: VARCHAR(20)
   Description: Type of content
   Possible Values: "Movie" or "TV Show"
   Constraints:
   - NOT NULL (required)
   - Limited to specific choices
   Validators: Automatically validated by choices parameter
   Notes: Using choices for data integrity
   
   Implementation:
   ```python
   TYPE_CHOICES = [
       ('Movie', 'Movie'),
       ('TV Show', 'TV Show'),
   ]
   type = models.CharField(max_length=20, choices=TYPE_CHOICES)
   ```

3. title
   -----
   Django Field: CharField(max_length=250)
   Database Type: VARCHAR(250)
   Description: Title of the movie or TV show
   Example Values: "Dick Johnson Is Dead", "Stranger Things", "The Crown"
   Constraints:
   - NOT NULL (required)
   Validators: MinLengthValidator(1) - ensure not empty
   Notes: 250 chars should handle longest titles

4. director
   --------
   Django Field: CharField(max_length=250, blank=True, null=True)
   Database Type: VARCHAR(250) NULL
   Description: Director(s) of the content (comma-separated if multiple)
   Example Values: "Martin Scorsese", "Christopher Nolan", ""
   Constraints:
   - NULL allowed (~30% missing in dataset)
   - BLANK allowed (can be empty string)
   Validators: None (optional field)
   Notes: Multiple directors stored as comma-separated string
   
   Handling in queries:
   - Can split by comma if needed
   - Can use __icontains for searching specific director

5. cast
   ----
   Django Field: TextField(blank=True, null=True)
   Database Type: TEXT NULL
   Description: Comma-separated list of actors
   Example Values: "Tom Hanks, Tim Allen, Don Rickles"
   Constraints:
   - NULL allowed (~9% missing)
   - BLANK allowed
   Validators: None (optional field)
   Notes: Using TextField because cast can be very long (20+ actors)
   
   Handling in queries:
   - Can split by comma for cast member searches
   - Can use __icontains for actor searches

6. country
   -------
   Django Field: CharField(max_length=150, blank=True, null=True)
   Database Type: VARCHAR(150) NULL
   Description: Country/countries where content was produced
   Example Values: "United States", "India", "United States, India"
   Constraints:
   - NULL allowed (~7% missing)
   - BLANK allowed
   Validators: None (optional field)
   Notes: Can contain multiple countries (comma-separated)
   
   Handling in queries:
   - Use __icontains for country searches
   - Example: country__icontains='United States'

7. date_added
   ----------
   Django Field: DateField(blank=True, null=True)
   Database Type: DATE NULL
   Description: Date when content was added to Netflix
   Example Values: date(2021, 9, 25), date(2020, 1, 1)
   Constraints:
   - NULL allowed (11 missing values in dataset)
   - BLANK allowed
   Validators: None (but parse carefully during data loading)
   Notes: Store as proper date object, not string
   
   CSV Format: "September 25, 2021" → needs parsing
   Parsing in load script:
   ```python
   from datetime import datetime
   date_str = "September 25, 2021"
   date_obj = datetime.strptime(date_str, "%B %d, %Y").date()
   ```
   
   Query capabilities:
   - Filter by year: date_added__year=2020
   - Filter by range: date_added__gte=date(2020, 1, 1)
   - Extract year/month for aggregations

8. release_year
   ------------
   Django Field: IntegerField()
   Database Type: INTEGER
   Description: Original release year of the content
   Example Values: 2021, 2020, 1975, 1942
   Constraints:
   - NOT NULL (required)
   Validators: 
   - MinValueValidator(1900) - reasonable minimum year
   - MaxValueValidator(2030) - prevent future dates beyond reason
   Notes: Always present in dataset
   
   Implementation:
   ```python
   from django.core.validators import MinValueValidator, MaxValueValidator
   
   release_year = models.IntegerField(
       validators=[
           MinValueValidator(1900),
           MaxValueValidator(2030)
       ]
   )
   ```
   
   Query capabilities:
   - Filter by exact year: release_year=2020
   - Filter by range: release_year__gte=2015
   - Filter by decade: release_year__range=(2010, 2019)

9. rating
   ------
   Django Field: CharField(max_length=10, blank=True, null=True)
   Database Type: VARCHAR(10) NULL
   Description: TV/Movie content rating
   Possible Values: TV-MA, TV-14, TV-PG, R, PG-13, PG, G, TV-Y, TV-Y7, 
                    TV-G, NC-17, NR, UR
   Constraints:
   - NULL allowed (4 missing values)
   - BLANK allowed
   Validators: Could add choices, but ratings may change over time
   Notes: Don't use choices to allow flexibility
   
   Alternative with validation:
   ```python
   RATING_CHOICES = [
       ('TV-MA', 'TV-MA'),
       ('TV-14', 'TV-14'),
       ('TV-PG', 'TV-PG'),
       ('R', 'R'),
       ('PG-13', 'PG-13'),
       ('PG', 'PG'),
       ('G', 'G'),
       ('TV-Y', 'TV-Y'),
       ('TV-Y7', 'TV-Y7'),
       ('TV-G', 'TV-G'),
       ('NC-17', 'NC-17'),
       ('NR', 'NR'),
       ('UR', 'UR'),
   ]
   rating = models.CharField(max_length=10, choices=RATING_CHOICES, 
                             blank=True, null=True)
   ```
   
   Recommendation: Use CharField without choices for flexibility

10. duration
    --------
    Django Field: CharField(max_length=20)
    Database Type: VARCHAR(20)
    Description: Movie duration (minutes) OR TV show seasons
    Format Movies: "90 min", "120 min", "45 min"
    Format TV Shows: "1 Season", "2 Seasons", "10 Seasons"
    Constraints:
    - NOT NULL (required)
    Validators: None (format varies by type)
    Notes: Store as-is, parse when needed based on 'type' field
    
    Parsing in views:
    ```python
    if title.type == 'Movie':
        # Extract minutes: "90 min" → 90
        duration_mins = int(title.duration.split()[0])
    else:  # TV Show
        # Extract seasons: "2 Seasons" → 2
        duration_seasons = int(title.duration.split()[0])
    ```
    
    Alternative: Create separate fields
    ```python
    duration_minutes = models.IntegerField(blank=True, null=True)
    duration_seasons = models.IntegerField(blank=True, null=True)
    ```
    Recommendation: Keep as CharField for simplicity

11. listed_in
    ---------
    Django Field: TextField()
    Database Type: TEXT
    Description: Comma-separated list of genres/categories
    Example Values: "Documentaries", 
                   "International TV Shows, TV Dramas, TV Mysteries"
    Constraints:
    - NOT NULL (required)
    Validators: MinLengthValidator(1) - ensure not empty
    Notes: Multiple genres as comma-separated string
    
    Handling in queries:
    - Search for genre: listed_in__icontains='Drama'
    - Will match "Dramas", "TV Dramas", "Romantic Dramas", etc.
    
    Parsing for statistics:
    ```python
    genres = title.listed_in.split(',')
    genres = [g.strip() for g in genres]
    ```

12. description
    -----------
    Django Field: TextField()
    Database Type: TEXT
    Description: Brief synopsis/description of the content
    Example Values: "As her father nears the end of his life, filmmaker..."
    Constraints:
    - NOT NULL (required)
    Validators: MinLengthValidator(1) - ensure not empty
    Notes: Full-text search potential
    
    Query capabilities:
    - Search: description__icontains='zombie'
    - Full-text search (if needed): description__search='zombie apocalypse'

13. created_at (ADDITIONAL FIELD - Optional but Recommended)
    ----------
    Django Field: DateTimeField(auto_now_add=True)
    Database Type: DATETIME
    Description: Timestamp when record was created in our database
    Constraints:
    - Automatically set on creation
    - Cannot be modified
    Notes: Good practice for tracking when data was loaded
    
    ```python
    created_at = models.DateTimeField(auto_now_add=True)
    ```

14. updated_at (ADDITIONAL FIELD - Optional but Recommended)
    ----------
    Django Field: DateTimeField(auto_now=True)
    Database Type: DATETIME
    Description: Timestamp when record was last modified
    Constraints:
    - Automatically updated on save
    Notes: Good practice for tracking changes
    
    ```python
    updated_at = models.DateTimeField(auto_now=True)
    ```

================================================================================
COMPLETE MODEL CODE:
================================================================================

```python
from django.db import models
from django.core.validators import MinValueValidator, MaxValueValidator, MinLengthValidator

class NetflixTitle(models.Model):
    """
    Model representing a Netflix movie or TV show.
    
    This model stores comprehensive metadata about Netflix content including
    title information, release details, ratings, and categorization.
    """
    
    # Type choices for content
    TYPE_CHOICES = [
        ('Movie', 'Movie'),
        ('TV Show', 'TV Show'),
    ]
    
    # Primary identification
    show_id = models.CharField(
        max_length=20,
        unique=True,
        primary_key=True,
        help_text="Unique identifier for this title"
    )
    
    # Content type and title
    type = models.CharField(
        max_length=20,
        choices=TYPE_CHOICES,
        help_text="Type of content: Movie or TV Show"
    )
    
    title = models.CharField(
        max_length=250,
        validators=[MinLengthValidator(1)],
        help_text="Title of the movie or TV show"
    )
    
    # Production details
    director = models.CharField(
        max_length=250,
        blank=True,
        null=True,
        help_text="Director(s) - comma-separated if multiple"
    )
    
    cast = models.TextField(
        blank=True,
        null=True,
        help_text="Cast members - comma-separated list"
    )
    
    country = models.CharField(
        max_length=150,
        blank=True,
        null=True,
        help_text="Country/countries of production - comma-separated if multiple"
    )
    
    # Temporal information
    date_added = models.DateField(
        blank=True,
        null=True,
        help_text="Date when content was added to Netflix"
    )
    
    release_year = models.IntegerField(
        validators=[
            MinValueValidator(1900),
            MaxValueValidator(2030)
        ],
        help_text="Original release year of the content"
    )
    
    # Content classification
    rating = models.CharField(
        max_length=10,
        blank=True,
        null=True,
        help_text="Content rating (e.g., TV-MA, PG-13, R)"
    )
    
    duration = models.CharField(
        max_length=20,
        help_text="Duration - minutes for movies, seasons for TV shows"
    )
    
    # Categorization and description
    listed_in = models.TextField(
        validators=[MinLengthValidator(1)],
        help_text="Genres/categories - comma-separated list"
    )
    
    description = models.TextField(
        validators=[MinLengthValidator(1)],
        help_text="Brief description or synopsis"
    )
    
    # Metadata (optional but recommended)
    created_at = models.DateTimeField(
        auto_now_add=True,
        help_text="When this record was created in our database"
    )
    
    updated_at = models.DateTimeField(
        auto_now=True,
        help_text="When this record was last updated"
    )
    
    class Meta:
        ordering = ['-date_added', '-release_year']
        verbose_name = "Netflix Title"
        verbose_name_plural = "Netflix Titles"
        indexes = [
            models.Index(fields=['type']),
            models.Index(fields=['release_year']),
            models.Index(fields=['date_added']),
            models.Index(fields=['rating']),
        ]
    
    def __str__(self):
        """String representation of the model"""
        return f"{self.title} ({self.release_year}) - {self.type}"
    
    def get_genres(self):
        """
        Helper method to get list of genres.
        Returns list of genre strings.
        """
        return [genre.strip() for genre in self.listed_in.split(',')]
    
    def get_cast_list(self):
        """
        Helper method to get list of cast members.
        Returns list of cast member names or empty list if no cast.
        """
        if not self.cast:
            return []
        return [member.strip() for member in self.cast.split(',')]
    
    def get_duration_minutes(self):
        """
        Helper method to extract duration in minutes for movies.
        Returns integer or None if not a movie.
        """
        if self.type == 'Movie' and 'min' in self.duration:
            return int(self.duration.split()[0])
        return None
    
    def get_duration_seasons(self):
        """
        Helper method to extract number of seasons for TV shows.
        Returns integer or None if not a TV show.
        """
        if self.type == 'TV Show' and 'Season' in self.duration:
            return int(self.duration.split()[0])
        return None
```

================================================================================
MODEL FIELD SUMMARY TABLE:
================================================================================

| Field        | Type         | Required | Null | Blank | Validators           | Notes                    |
|--------------|--------------|----------|------|-------|---------------------|--------------------------|
| show_id      | CharField    | Yes      | No   | No    | None                | Primary Key, Unique      |
| type         | CharField    | Yes      | No   | No    | Choices             | Movie or TV Show         |
| title        | CharField    | Yes      | No   | No    | MinLength(1)        | 250 chars max            |
| director     | CharField    | No       | Yes  | Yes   | None                | ~30% null in data        |
| cast         | TextField    | No       | Yes  | Yes   | None                | ~9% null in data         |
| country      | CharField    | No       | Yes  | Yes   | None                | ~7% null in data         |
| date_added   | DateField    | No       | Yes  | Yes   | None                | Parse from string        |
| release_year | IntegerField | Yes      | No   | No    | Min(1900)/Max(2030) | Always present           |
| rating       | CharField    | No       | Yes  | Yes   | None                | ~4 null in data          |
| duration     | CharField    | Yes      | No   | No    | None                | Mixed format             |
| listed_in    | TextField    | Yes      | No   | No    | MinLength(1)        | Comma-separated genres   |
| description  | TextField    | Yes      | No   | No    | MinLength(1)        | Synopsis                 |
| created_at   | DateTimeField| Auto     | No   | No    | None                | Auto timestamp           |
| updated_at   | DateTimeField| Auto     | No   | No    | None                | Auto update              |

================================================================================
DATABASE SCHEMA DIAGRAM (ASCII):
================================================================================

┌─────────────────────────────────────────────────────────────────┐
│                      NetflixTitle                                │
├─────────────────────────────────────────────────────────────────┤
│ PK  show_id             VARCHAR(20)         UNIQUE              │
│     type                VARCHAR(20)         NOT NULL  [Choices] │
│     title               VARCHAR(250)        NOT NULL            │
│     director            VARCHAR(250)        NULL                │
│     cast                TEXT                NULL                │
│     country             VARCHAR(150)        NULL                │
│     date_added          DATE                NULL                │
│     release_year        INTEGER             NOT NULL  [1900-2030]│
│     rating              VARCHAR(10)         NULL                │
│     duration            VARCHAR(20)         NOT NULL            │
│     listed_in           TEXT                NOT NULL            │
│     description         TEXT                NOT NULL            │
│     created_at          DATETIME            NOT NULL  [Auto]    │
│     updated_at          DATETIME            NOT NULL  [Auto]    │
└─────────────────────────────────────────────────────────────────┘

Indexes:
- PRIMARY KEY on show_id
- INDEX on type (for fast filtering Movie vs TV Show)
- INDEX on release_year (for date range queries)
- INDEX on date_added (for temporal queries)
- INDEX on rating (for rating-based filtering)

================================================================================
ALTERNATIVE DESIGN: MULTIPLE MODELS (If Time Permits)
================================================================================

If you want to demonstrate Django relationships (ForeignKey, ManyToMany),
consider this alternative design:

MODEL 1: NetflixTitle (Main table)
-----------------------------------
- show_id (PK)
- type
- title
- director (still as text - directors not standardized enough)
- cast (still as text)
- country
- date_added
- release_year
- rating
- duration
- description
- created_at
- updated_at

MODEL 2: Genre
--------------
- id (PK, auto)
- name (unique)

RELATIONSHIP: ManyToMany
NetflixTitle.genres = ManyToManyField(Genre)
(One title can have multiple genres, one genre can belong to multiple titles)

IMPLEMENTATION:
```python
class Genre(models.Model):
    name = models.CharField(max_length=100, unique=True)
    
    def __str__(self):
        return self.name

class NetflixTitle(models.Model):
    # ... all fields except listed_in ...
    genres = models.ManyToManyField(Genre, related_name='titles')
```

PROS:
- Demonstrates Django relationships
- Better normalized database
- Easier genre-based queries
- Shows ManyToMany understanding

CONS:
- More complex data loading (need to create Genre objects first)
- More complex queries (need joins)
- Takes more time to implement

RECOMMENDATION: Only implement if you have extra time after completing
                main requirements. Single model is sufficient for full marks.

================================================================================
MODEL DESIGN DECISIONS & JUSTIFICATIONS (For Report):
================================================================================

DECISION 1: Single Model vs Multiple Models
--------------------------------------------
Choice: Single Model (NetflixTitle)
Reason: 
- Dataset structure maps directly to single table
- Simpler to implement and maintain
- Sufficient for demonstrating all required Django features
- Faster query performance for most use cases
- Easier data loading from CSV
- Still allows complex queries with filtering, aggregation, annotations

DECISION 2: show_id as Primary Key
-----------------------------------
Choice: Use show_id as primary key instead of auto-generated id
Reason:
- show_id is already unique in dataset
- More meaningful than auto-increment id
- Directly maps to data source
- Easier debugging (can identify records by show_id)
- RESTful URLs more readable (/api/titles/s1/ vs /api/titles/1/)

DECISION 3: Storage of Multi-Value Fields (cast, genres, country)
------------------------------------------------------------------
Choice: Store as comma-separated text instead of related models
Reason:
- Values not standardized in source data
- Many variations in spelling/formatting
- Sufficient for search queries using __icontains
- Simpler implementation
- Can split in views when needed
- Alternative: Could normalize later if needed

DECISION 4: date_added as DateField not CharField
--------------------------------------------------
Choice: Parse string dates and store as proper DateField
Reason:
- Enables date-based queries (year, month, range)
- Proper data type for temporal data
- Can use Django's date filters and aggregations
- Better for sorting and comparisons
- Demonstrate data parsing skills in load script

DECISION 5: duration as CharField not separate integer fields
-------------------------------------------------------------
Choice: Keep mixed format ("90 min" / "2 Seasons") as single CharField
Reason:
- Preserves original data format
- Can parse when needed based on type field
- Simpler model structure
- Helper methods (get_duration_minutes, get_duration_seasons) handle parsing
- Alternative would require conditional logic during data loading

DECISION 6: Validators on Numeric Fields
-----------------------------------------
Choice: Add MinValueValidator and MaxValueValidator on release_year
Reason:
- Demonstrates proper use of Django validators (R1b requirement)
- Prevents invalid data (year 3000 or year 500)
- Reasonable constraints (1900-2030)
- Shows data integrity awareness
- Easy to adjust if needed

DECISION 7: Optional Metadata Fields (created_at, updated_at)
--------------------------------------------------------------
Choice: Include these additional tracking fields
Reason:
- Professional practice (shows real-world awareness)
- Useful for debugging data loading
- Minimal overhead
- Demonstrates auto_now and auto_now_add
- Good for tracking when data was imported

DECISION 8: Meta Class Ordering
--------------------------------
Choice: Order by date_added (desc), then release_year (desc)
Reason:
- Default ordering shows newest content first
- Matches typical user expectations
- date_added shows Netflix acquisition strategy
- Falls back to release_year if date_added is null

DECISION 9: Database Indexes
-----------------------------
Choice: Add indexes on frequently filtered fields (type, release_year, 
        date_added, rating)
Reason:
- Improves query performance
- Common filter fields in API endpoints
- Small performance cost on writes, big gain on reads
- Demonstrates database optimization awareness

================================================================================
VALIDATION STRATEGY:
================================================================================

FIELD-LEVEL VALIDATORS:
----------------------
1. release_year: MinValueValidator(1900), MaxValueValidator(2030)
2. title: MinLengthValidator(1)
3. listed_in: MinLengthValidator(1)
4. description: MinLengthValidator(1)

MODEL-LEVEL VALIDATION (Optional - in clean() method):
------------------------------------------------------
```python
def clean(self):
    """
    Custom model validation
    """
    from django.core.exceptions import ValidationError
    
    # Ensure duration format matches type
    if self.type == 'Movie' and 'min' not in self.duration.lower():
        raise ValidationError({
            'duration': 'Movie duration must be in minutes (e.g., "90 min")'
        })
    
    if self.type == 'TV Show' and 'season' not in self.duration.lower():
        raise ValidationError({
            'duration': 'TV Show duration must be in seasons (e.g., "2 Seasons")'
        })
    
    # Ensure release_year not in future
    from datetime import datetime
    current_year = datetime.now().year
    if self.release_year > current_year + 1:
        raise ValidationError({
            'release_year': f'Release year cannot be more than {current_year + 1}'
        })
```

SERIALIZER-LEVEL VALIDATION (Required for POST endpoint):
---------------------------------------------------------
Will be implemented in serializers.py (Step 5)
- Validates all required fields are present
- Checks data types match
- Runs model validators
- Custom validation rules

================================================================================
STEP 1.2 COMPLETION CHECKLIST:
================================================================================

☑ Sketch out the database schema on paper/diagram
  ✓ ASCII diagram created above
  
☑ Identify entities (tables/models needed)
  ✓ Decision: Single model - NetflixTitle
  ✓ Alternative documented: Multiple models with Genre relationship
  
☑ Define fields for each model with data types
  ✓ All 14 fields defined with Django types
  ✓ Constraints specified (null, blank, max_length, etc.)
  
☑ Identify relationships (ForeignKey, ManyToMany, OneToOne)
  ✓ Current design: None (single model)
  ✓ Alternative design: ManyToMany with Genre (documented for future)
  
☑ Plan any necessary validators
  ✓ Field-level validators defined
  ✓ Optional model-level validation documented
  
☑ Document model decisions (for report)
  ✓ 9 design decisions documented with justifications
  ✓ Rationale for single-model approach explained

DELIVERABLE: Database schema diagram ✓ COMPLETE
DECISION: Single NetflixTitle model (can add Genre relationship later) ✓

================================================================================
FILES PRODUCED:
================================================================================

This document contains:
1. Complete model code (ready to use in Step 3.1)
2. Field-by-field specifications
3. Database schema diagram
4. Design decisions with justifications (for report Section 3)
5. Alternative multi-model design (if time permits)
6. Validation strategy

Ready for use in:
- Phase 3 (Models Implementation)
- Report Section 3 (Database Design)

================================================================================
READY FOR STEP 1.3: Plan REST API Endpoints
================================================================================

Next tasks:
- Design 6 RESTful endpoints
- Map endpoints to query complexity
- Ensure POST endpoint included
- Ensure serialization demonstrated
- Define URL patterns

================================================================================
END OF MODEL DESIGN
================================================================================
