================================================================================
NETFLIX REST API - ENDPOINT DESIGN SPECIFICATION
Step 1.3: Plan REST API Endpoints (6 Required)
================================================================================

PROJECT: CM3035 Advanced Web Development Coursework
DATASET: Netflix Movies and TV Shows
DATE: December 14, 2024

================================================================================
ENDPOINT DESIGN REQUIREMENTS:
================================================================================

From Coursework Specification:
------------------------------
✓ Total endpoints required: 6
✓ At least ONE must use POST (for creating/saving data)
✓ At least ONE must use serialization
✓ Should demonstrate query complexity
✓ Should be "interesting" - demonstrate Django knowledge

Additional Considerations:
-------------------------
✓ Cover variety of HTTP methods (GET, POST)
✓ Range from simple to complex queries
✓ Use Django ORM features (filtering, aggregation, annotations)
✓ Demonstrate Q objects for complex conditions
✓ Show serializer usage and validation
✓ Return meaningful, useful data

================================================================================
ENDPOINT SUMMARY TABLE:
================================================================================

| # | Endpoint                  | Method | Complexity | Key Features              |
|---|---------------------------|--------|------------|---------------------------|
| 1 | /api/titles/              | GET    | Simple     | Basic listing with filters|
| 2 | /api/titles/create/       | POST   | Medium     | Create new title          |
| 3 | /api/statistics/          | GET    | Complex    | Aggregations & analytics  |
| 4 | /api/titles/search/       | GET    | Complex    | Multi-filter search       |
| 5 | /api/country/<country>/   | GET    | Medium     | Country-specific data     |
| 6 | /api/recommendations/     | GET    | Complex    | Advanced recommendation   |

Requirements Coverage:
- POST endpoint: ✓ Endpoint 2
- Serialization: ✓ All endpoints (NetflixTitleSerializer)
- Complex queries: ✓ Endpoints 3, 4, 6
- Variety: ✓ Simple, medium, complex
- Interesting: ✓ Real-world use cases

================================================================================
ENDPOINT 1: GET ALL TITLES (WITH OPTIONAL FILTERS)
================================================================================

PURPOSE:
--------
Retrieve list of Netflix titles with optional filtering by type, rating, or year.
This is the most basic endpoint for browsing content.

HTTP METHOD: GET
URL PATTERN: /api/titles/
URL NAME: 'title-list'

QUERY PARAMETERS (Optional):
----------------------------
- type: Filter by content type (Movie or TV Show)
  Example: ?type=Movie
  
- rating: Filter by specific rating
  Example: ?rating=TV-MA
  
- year: Filter by release year
  Example: ?year=2020
  
- year_min: Filter by minimum release year
  Example: ?year_min=2015
  
- year_max: Filter by maximum release year
  Example: ?year_max=2021

EXAMPLES:
---------
1. Get all titles:
   GET /api/titles/
   
2. Get all movies:
   GET /api/titles/?type=Movie
   
3. Get TV-MA rated content:
   GET /api/titles/?rating=TV-MA
   
4. Get movies from 2020:
   GET /api/titles/?type=Movie&year=2020
   
5. Get content from 2015-2020:
   GET /api/titles/?year_min=2015&year_max=2020

DJANGO ORM QUERY:
-----------------
```python
from django.db.models import Q

def get_queryset(request):
    queryset = NetflixTitle.objects.all()
    
    # Filter by type
    content_type = request.GET.get('type')
    if content_type:
        queryset = queryset.filter(type=content_type)
    
    # Filter by rating
    rating = request.GET.get('rating')
    if rating:
        queryset = queryset.filter(rating=rating)
    
    # Filter by exact year
    year = request.GET.get('year')
    if year:
        queryset = queryset.filter(release_year=year)
    
    # Filter by year range
    year_min = request.GET.get('year_min')
    if year_min:
        queryset = queryset.filter(release_year__gte=year_min)
    
    year_max = request.GET.get('year_max')
    if year_max:
        queryset = queryset.filter(release_year__lte=year_max)
    
    return queryset
```

RESPONSE FORMAT:
----------------
Status Code: 200 OK
Content-Type: application/json

```json
[
    {
        "show_id": "s1",
        "type": "Movie",
        "title": "Dick Johnson Is Dead",
        "director": "Kirsten Johnson",
        "cast": null,
        "country": "United States",
        "date_added": "2021-09-25",
        "release_year": 2020,
        "rating": "PG-13",
        "duration": "90 min",
        "listed_in": "Documentaries",
        "description": "As her father nears the end of his life..."
    },
    {
        "show_id": "s2",
        "type": "TV Show",
        "title": "Blood & Water",
        ...
    }
]
```

SERIALIZER USAGE:
-----------------
Uses: NetflixTitleSerializer(queryset, many=True)

COMPLEXITY: ⭐ SIMPLE
Features: Basic filtering, multiple optional parameters

WHY INTERESTING:
---------------
- Foundation endpoint for browsing
- Demonstrates optional query parameters
- Shows basic Django filtering
- Real-world use case: content discovery

================================================================================
ENDPOINT 2: CREATE NEW TITLE (POST - REQUIRED)
================================================================================

PURPOSE:
--------
Create a new Netflix title entry. This endpoint demonstrates POST method,
serializer validation, and data creation.

HTTP METHOD: POST
URL PATTERN: /api/titles/create/
URL NAME: 'title-create'

REQUEST BODY (JSON):
--------------------
Content-Type: application/json

Required fields:
- show_id: Unique identifier
- type: "Movie" or "TV Show"
- title: Title of content
- release_year: Year (1900-2030)
- duration: e.g., "90 min" or "2 Seasons"
- listed_in: Genres (comma-separated)
- description: Description text

Optional fields:
- director: Director name(s)
- cast: Cast members
- country: Country/countries
- date_added: Date added to Netflix (YYYY-MM-DD)
- rating: Content rating

EXAMPLE REQUEST:
----------------
POST /api/titles/create/
Content-Type: application/json

```json
{
    "show_id": "s9999",
    "type": "Movie",
    "title": "My Custom Movie",
    "director": "John Doe",
    "cast": "Actor One, Actor Two, Actor Three",
    "country": "United States",
    "date_added": "2024-12-14",
    "release_year": 2024,
    "rating": "PG-13",
    "duration": "120 min",
    "listed_in": "Action & Adventure, Dramas",
    "description": "An exciting new film about Django development."
}
```

DJANGO VIEW LOGIC:
------------------
```python
from rest_framework import status
from rest_framework.decorators import api_view
from rest_framework.response import Response

@api_view(['POST'])
def create_title(request):
    """
    Create a new Netflix title.
    Demonstrates POST method and serializer validation.
    """
    serializer = NetflixTitleSerializer(data=request.data)
    
    if serializer.is_valid():
        serializer.save()
        return Response(
            serializer.data,
            status=status.HTTP_201_CREATED
        )
    
    return Response(
        serializer.errors,
        status=status.HTTP_400_BAD_REQUEST
    )
```

RESPONSE FORMAT (Success):
--------------------------
Status Code: 201 Created
Content-Type: application/json

```json
{
    "show_id": "s9999",
    "type": "Movie",
    "title": "My Custom Movie",
    "director": "John Doe",
    "cast": "Actor One, Actor Two, Actor Three",
    "country": "United States",
    "date_added": "2024-12-14",
    "release_year": 2024,
    "rating": "PG-13",
    "duration": "120 min",
    "listed_in": "Action & Adventure, Dramas",
    "description": "An exciting new film about Django development.",
    "created_at": "2024-12-14T10:30:00Z",
    "updated_at": "2024-12-14T10:30:00Z"
}
```

RESPONSE FORMAT (Validation Error):
-----------------------------------
Status Code: 400 Bad Request
Content-Type: application/json

```json
{
    "show_id": ["This field is required."],
    "release_year": ["Ensure this value is less than or equal to 2030."]
}
```

SERIALIZER VALIDATION:
---------------------
The serializer automatically validates:
- Required fields are present
- Data types are correct
- show_id is unique
- release_year is within valid range (1900-2030)
- type is either "Movie" or "TV Show"
- All string fields within max_length limits

COMPLEXITY: ⭐⭐ MEDIUM
Features: POST method, serializer validation, error handling, 201 status

WHY INTERESTING:
---------------
- Required POST endpoint ✓
- Demonstrates serializer.is_valid() (R1b requirement) ✓
- Shows proper HTTP status codes (201, 400)
- Real-world use case: content management system
- Demonstrates data validation

================================================================================
ENDPOINT 3: GET STATISTICS & ANALYTICS
================================================================================

PURPOSE:
--------
Provide comprehensive statistics about the Netflix catalog including counts,
distributions, and trends. Demonstrates complex aggregations and annotations.

HTTP METHOD: GET
URL PATTERN: /api/statistics/
URL NAME: 'statistics'

QUERY PARAMETERS: None (returns overall statistics)

DJANGO ORM QUERY:
-----------------
```python
from django.db.models import Count, Avg, Max, Min, Q
from django.db.models.functions import ExtractYear

def get_statistics():
    # Total counts
    total_titles = NetflixTitle.objects.count()
    
    # Type distribution
    type_distribution = NetflixTitle.objects.values('type').annotate(
        count=Count('show_id'),
    ).order_by('-count')
    
    # Rating distribution (top 10)
    rating_distribution = NetflixTitle.objects.exclude(
        rating__isnull=True
    ).values('rating').annotate(
        count=Count('show_id')
    ).order_by('-count')[:10]
    
    # Content added by year
    content_by_year = NetflixTitle.objects.exclude(
        date_added__isnull=True
    ).annotate(
        year=ExtractYear('date_added')
    ).values('year').annotate(
        count=Count('show_id')
    ).order_by('year')
    
    # Top 10 countries by content production
    top_countries = NetflixTitle.objects.exclude(
        country__isnull=True
    ).exclude(
        country__exact=''
    ).values('country').annotate(
        count=Count('show_id')
    ).order_by('-count')[:10]
    
    # Release year statistics
    release_stats = NetflixTitle.objects.aggregate(
        earliest=Min('release_year'),
        latest=Max('release_year'),
        average=Avg('release_year')
    )
    
    # Content by decade
    # Group by decade (2020s, 2010s, 2000s, etc.)
    decades = {}
    for title in NetflixTitle.objects.all():
        decade = (title.release_year // 10) * 10
        decade_label = f"{decade}s"
        decades[decade_label] = decades.get(decade_label, 0) + 1
    
    return {
        'total_titles': total_titles,
        'type_distribution': list(type_distribution),
        'rating_distribution': list(rating_distribution),
        'content_by_year': list(content_by_year),
        'top_countries': list(top_countries),
        'release_year_stats': release_stats,
        'content_by_decade': decades
    }
```

RESPONSE FORMAT:
----------------
Status Code: 200 OK
Content-Type: application/json

```json
{
    "total_titles": 8810,
    "type_distribution": [
        {"type": "Movie", "count": 6131},
        {"type": "TV Show", "count": 2679}
    ],
    "rating_distribution": [
        {"rating": "TV-MA", "count": 3207},
        {"rating": "TV-14", "count": 2160},
        {"rating": "TV-PG", "count": 863},
        {"rating": "R", "count": 799},
        {"rating": "PG-13", "count": 490},
        ...
    ],
    "content_by_year": [
        {"year": 2008, "count": 1},
        {"year": 2009, "count": 3},
        {"year": 2010, "count": 2},
        ...
        {"year": 2020, "count": 1695},
        {"year": 2021, "count": 1564}
    ],
    "top_countries": [
        {"country": "United States", "count": 2818},
        {"country": "India", "count": 972},
        {"country": "United Kingdom", "count": 419},
        ...
    ],
    "release_year_stats": {
        "earliest": 1925,
        "latest": 2021,
        "average": 2013.5
    },
    "content_by_decade": {
        "2020s": 2890,
        "2010s": 4205,
        "2000s": 1180,
        "1990s": 345,
        ...
    }
}
```

SERIALIZER USAGE:
-----------------
Custom response format (dictionary), not using model serializer.
Could create custom serializer if desired.

COMPLEXITY: ⭐⭐⭐⭐ COMPLEX
Features: Multiple aggregations (Count, Avg, Min, Max), annotations,
          ExtractYear, exclude filters, ordering, grouping

WHY INTERESTING:
---------------
- Demonstrates Django aggregation functions
- Shows annotations and computed fields
- Multiple complex queries in one endpoint
- Real-world use case: dashboard analytics
- Business intelligence insights
- Useful for data visualization

================================================================================
ENDPOINT 4: ADVANCED MULTI-FILTER SEARCH
================================================================================

PURPOSE:
--------
Advanced search endpoint with multiple filter options that can be combined.
Demonstrates complex filtering with Q objects and multiple conditions.

HTTP METHOD: GET
URL PATTERN: /api/titles/search/
URL NAME: 'title-search'

QUERY PARAMETERS (All Optional, Can Combine):
---------------------------------------------
- type: Content type (Movie or TV Show)
- rating: Specific rating
- country: Country name (partial match)
- year_min: Minimum release year
- year_max: Maximum release year
- genre: Genre keyword (searches in listed_in)
- director: Director name (partial match)
- cast: Actor name (partial match)
- title_keyword: Search in title

EXAMPLES:
---------
1. Search for R-rated movies from USA after 2015:
   GET /api/titles/search/?type=Movie&rating=R&country=United States&year_min=2015

2. Search for drama TV shows:
   GET /api/titles/search/?type=TV Show&genre=Drama

3. Search for movies with "Tom Hanks":
   GET /api/titles/search/?type=Movie&cast=Tom Hanks

4. Search for comedies from 2010s:
   GET /api/titles/search/?genre=Comed&year_min=2010&year_max=2019

5. Search for content with "love" in title:
   GET /api/titles/search/?title_keyword=love

DJANGO ORM QUERY:
-----------------
```python
from django.db.models import Q

@api_view(['GET'])
def search_titles(request):
    """
    Advanced search with multiple filters.
    Demonstrates Q objects and complex filtering.
    """
    queryset = NetflixTitle.objects.all()
    
    # Build Q objects for complex conditions
    filters = Q()
    
    # Type filter
    content_type = request.GET.get('type')
    if content_type:
        filters &= Q(type=content_type)
    
    # Rating filter
    rating = request.GET.get('rating')
    if rating:
        filters &= Q(rating=rating)
    
    # Country filter (case-insensitive partial match)
    country = request.GET.get('country')
    if country:
        filters &= Q(country__icontains=country)
    
    # Year range filters
    year_min = request.GET.get('year_min')
    if year_min:
        filters &= Q(release_year__gte=year_min)
    
    year_max = request.GET.get('year_max')
    if year_max:
        filters &= Q(release_year__lte=year_max)
    
    # Genre filter (searches in listed_in field)
    genre = request.GET.get('genre')
    if genre:
        filters &= Q(listed_in__icontains=genre)
    
    # Director filter (case-insensitive partial match)
    director = request.GET.get('director')
    if director:
        filters &= Q(director__icontains=director)
    
    # Cast filter (case-insensitive partial match)
    cast = request.GET.get('cast')
    if cast:
        filters &= Q(cast__icontains=cast)
    
    # Title keyword search
    title_keyword = request.GET.get('title_keyword')
    if title_keyword:
        filters &= Q(title__icontains=title_keyword)
    
    # Apply all filters
    queryset = queryset.filter(filters)
    
    # Order by date_added (newest first)
    queryset = queryset.order_by('-date_added', '-release_year')
    
    # Serialize and return
    serializer = NetflixTitleSerializer(queryset, many=True)
    return Response(serializer.data)
```

RESPONSE FORMAT:
----------------
Status Code: 200 OK
Content-Type: application/json

```json
[
    {
        "show_id": "s123",
        "type": "Movie",
        "title": "Action Movie Title",
        "director": "John Director",
        "cast": "Actor One, Actor Two",
        "country": "United States",
        "date_added": "2020-05-15",
        "release_year": 2019,
        "rating": "R",
        "duration": "120 min",
        "listed_in": "Action & Adventure, Thrillers",
        "description": "An exciting action movie..."
    },
    ...
]
```

EMPTY RESULTS:
--------------
```json
[]
```

SERIALIZER USAGE:
-----------------
Uses: NetflixTitleSerializer(queryset, many=True)

COMPLEXITY: ⭐⭐⭐⭐ VERY COMPLEX
Features: Q objects, multiple AND conditions, __icontains lookups,
          year ranges, complex boolean logic, 9 different filter options

WHY INTERESTING:
---------------
- Most complex query endpoint
- Demonstrates Q objects (advanced Django ORM)
- Multiple filter combinations
- Case-insensitive text searches
- Real-world use case: advanced content discovery
- Flexible search system
- Shows understanding of complex WHERE clauses

================================================================================
ENDPOINT 5: GET CONTENT BY COUNTRY
================================================================================

PURPOSE:
--------
Retrieve all Netflix content from a specific country with statistics breakdown.
Demonstrates parameterized URLs and country-specific analysis.

HTTP METHOD: GET
URL PATTERN: /api/country/<str:country_name>/
URL NAME: 'country-content'

URL PARAMETERS:
---------------
- country_name: Name of the country (e.g., "United States", "India", "Japan")

EXAMPLES:
---------
1. Get content from United States:
   GET /api/country/United States/

2. Get content from India:
   GET /api/country/India/

3. Get content from South Korea:
   GET /api/country/South Korea/

DJANGO ORM QUERY:
-----------------
```python
from django.db.models import Count

@api_view(['GET'])
def country_content(request, country_name):
    """
    Get all content from a specific country with statistics.
    """
    # Filter content by country (case-insensitive partial match)
    queryset = NetflixTitle.objects.filter(
        country__icontains=country_name
    )
    
    # Get statistics
    total_content = queryset.count()
    
    # Breakdown by type
    type_breakdown = queryset.values('type').annotate(
        count=Count('show_id')
    )
    
    # Breakdown by rating
    rating_breakdown = queryset.exclude(
        rating__isnull=True
    ).values('rating').annotate(
        count=Count('show_id')
    ).order_by('-count')
    
    # Average release year
    from django.db.models import Avg
    avg_year = queryset.aggregate(avg=Avg('release_year'))
    
    # Get all content
    serializer = NetflixTitleSerializer(queryset, many=True)
    
    return Response({
        'country': country_name,
        'total_content': total_content,
        'type_breakdown': list(type_breakdown),
        'rating_breakdown': list(rating_breakdown),
        'average_release_year': avg_year['avg'],
        'content': serializer.data
    })
```

RESPONSE FORMAT:
----------------
Status Code: 200 OK
Content-Type: application/json

```json
{
    "country": "United States",
    "total_content": 2818,
    "type_breakdown": [
        {"type": "Movie", "count": 2032},
        {"type": "TV Show", "count": 786}
    ],
    "rating_breakdown": [
        {"rating": "TV-MA", "count": 842},
        {"rating": "R", "count": 512},
        {"rating": "TV-14", "count": 398},
        ...
    ],
    "average_release_year": 2015.8,
    "content": [
        {
            "show_id": "s1",
            "type": "Movie",
            "title": "Dick Johnson Is Dead",
            "country": "United States",
            ...
        },
        ...
    ]
}
```

EMPTY RESULTS (Country not found):
----------------------------------
```json
{
    "country": "Unknown Country",
    "total_content": 0,
    "type_breakdown": [],
    "rating_breakdown": [],
    "average_release_year": null,
    "content": []
}
```

SERIALIZER USAGE:
-----------------
Uses: NetflixTitleSerializer for content list
Custom structure for overall response

COMPLEXITY: ⭐⭐⭐ MEDIUM-COMPLEX
Features: URL parameters, aggregations, multiple queries,
          combined statistics + data listing

WHY INTERESTING:
---------------
- Demonstrates URL path parameters
- Country-specific analysis
- Combines statistics with data listing
- Real-world use case: geographic content analysis
- Useful for understanding regional content strategies

================================================================================
ENDPOINT 6: GET RECOMMENDATIONS (ADVANCED LOGIC)
================================================================================

PURPOSE:
--------
Get content recommendations based on specified criteria. This endpoint
demonstrates complex business logic and conditional filtering.

HTTP METHOD: GET
URL PATTERN: /api/recommendations/
URL NAME: 'recommendations'

QUERY PARAMETERS:
-----------------
- genre: Preferred genre (required)
- rating: Preferred rating (optional, e.g., "TV-MA", "PG-13")
- type: Preferred type - Movie or TV Show (optional)
- recent: If "true", only show content added in last 3 years (optional)

EXAMPLES:
---------
1. Get drama recommendations:
   GET /api/recommendations/?genre=Drama

2. Get recent TV-MA action content:
   GET /api/recommendations/?genre=Action&rating=TV-MA&recent=true

3. Get PG-13 movie comedies:
   GET /api/recommendations/?genre=Comedy&type=Movie&rating=PG-13

DJANGO ORM QUERY:
-----------------
```python
from datetime import datetime, timedelta
from django.db.models import Q, Count
from django.db.models.functions import ExtractYear

@api_view(['GET'])
def get_recommendations(request):
    """
    Get content recommendations based on preferences.
    Demonstrates complex business logic and conditional filtering.
    """
    # Get parameters
    genre = request.GET.get('genre')
    if not genre:
        return Response(
            {'error': 'Genre parameter is required'},
            status=status.HTTP_400_BAD_REQUEST
        )
    
    rating = request.GET.get('rating')
    content_type = request.GET.get('type')
    recent = request.GET.get('recent', '').lower() == 'true'
    
    # Start with base query - filter by genre
    queryset = NetflixTitle.objects.filter(
        listed_in__icontains=genre
    )
    
    # Apply optional filters
    if rating:
        queryset = queryset.filter(rating=rating)
    
    if content_type:
        queryset = queryset.filter(type=content_type)
    
    # Filter by recent content (added in last 3 years)
    if recent:
        three_years_ago = datetime.now().date() - timedelta(days=3*365)
        queryset = queryset.filter(
            date_added__gte=three_years_ago
        )
    
    # Order by most recent first, then by release year
    queryset = queryset.order_by('-date_added', '-release_year')
    
    # Limit to top 20 recommendations
    queryset = queryset[:20]
    
    # Calculate recommendation statistics
    total_found = queryset.count()
    
    if total_found == 0:
        return Response({
            'message': 'No content found matching your preferences',
            'recommendations': []
        })
    
    # Serialize results
    serializer = NetflixTitleSerializer(queryset, many=True)
    
    return Response({
        'genre': genre,
        'rating': rating if rating else 'Any',
        'type': content_type if content_type else 'Any',
        'recent_only': recent,
        'total_found': total_found,
        'recommendations': serializer.data
    })
```

RESPONSE FORMAT:
----------------
Status Code: 200 OK
Content-Type: application/json

```json
{
    "genre": "Drama",
    "rating": "TV-MA",
    "type": "Any",
    "recent_only": true,
    "total_found": 20,
    "recommendations": [
        {
            "show_id": "s456",
            "type": "Movie",
            "title": "Dramatic Movie Title",
            "director": "Director Name",
            "cast": "Actor One, Actor Two",
            "country": "United States",
            "date_added": "2023-11-15",
            "release_year": 2023,
            "rating": "TV-MA",
            "duration": "135 min",
            "listed_in": "Dramas, International Movies",
            "description": "A powerful drama about..."
        },
        ...
    ]
}
```

ERROR RESPONSE (Missing genre):
-------------------------------
Status Code: 400 Bad Request

```json
{
    "error": "Genre parameter is required"
}
```

NO RESULTS RESPONSE:
--------------------
```json
{
    "message": "No content found matching your preferences",
    "recommendations": []
}
```

SERIALIZER USAGE:
-----------------
Uses: NetflixTitleSerializer for recommendations list
Custom structure for overall response

COMPLEXITY: ⭐⭐⭐⭐ COMPLEX
Features: Required parameters, optional filters, conditional logic,
          date calculations, ordering, limiting results, error handling

WHY INTERESTING:
---------------
- Real-world recommendation system
- Demonstrates conditional filtering
- Shows date arithmetic (recent content)
- Parameter validation with error responses
- Business logic implementation
- Useful for content discovery and personalization
- Combines multiple filtering strategies

================================================================================
ENDPOINT IMPLEMENTATION SUMMARY:
================================================================================

┌────────┬─────────────────────────┬────────┬──────────────┬──────────────────┐
│ Number │ Endpoint                │ Method │ Complexity   │ Key Django ORM   │
├────────┼─────────────────────────┼────────┼──────────────┼──────────────────┤
│   1    │ /api/titles/            │ GET    │ Simple       │ filter()         │
│        │                         │        │              │ optional params  │
├────────┼─────────────────────────┼────────┼──────────────┼──────────────────┤
│   2    │ /api/titles/create/     │ POST   │ Medium       │ serializer       │
│        │                         │        │              │ validation       │
├────────┼─────────────────────────┼────────┼──────────────┼──────────────────┤
│   3    │ /api/statistics/        │ GET    │ Complex      │ aggregate()      │
│        │                         │        │              │ annotate()       │
│        │                         │        │              │ Count, Avg, etc. │
├────────┼─────────────────────────┼────────┼──────────────┼──────────────────┤
│   4    │ /api/titles/search/     │ GET    │ Very Complex │ Q objects        │
│        │                         │        │              │ 9 filter options │
│        │                         │        │              │ __icontains      │
├────────┼─────────────────────────┼────────┼──────────────┼──────────────────┤
│   5    │ /api/country/<country>/ │ GET    │ Med-Complex  │ URL parameters   │
│        │                         │        │              │ aggregations     │
├────────┼─────────────────────────┼────────┼──────────────┼──────────────────┤
│   6    │ /api/recommendations/   │ GET    │ Complex      │ Conditional      │
│        │                         │        │              │ Date arithmetic  │
│        │                         │        │              │ Ordering         │
└────────┴─────────────────────────┴────────┴──────────────┴──────────────────┘

REQUIREMENTS COVERAGE:
======================

✓ 6 Endpoints designed
✓ At least ONE uses POST: Endpoint 2 ✓
✓ At least ONE uses serialization: ALL endpoints use NetflixTitleSerializer ✓
✓ Query complexity demonstrated: Endpoints 3, 4, 6 show advanced queries ✓
✓ Variety of HTTP methods: GET (5), POST (1) ✓
✓ Range of complexities: Simple (1), Medium (2), Complex (3) ✓

DJANGO ORM FEATURES DEMONSTRATED:
==================================

✓ filter() - Basic filtering
✓ Q objects - Complex boolean conditions
✓ aggregate() - Count, Avg, Min, Max
✓ annotate() - Computed fields
✓ values() - Specific field selection
✓ order_by() - Sorting
✓ exclude() - Negative filtering
✓ __icontains - Case-insensitive partial matching
✓ __gte, __lte - Comparison operators
✓ ExtractYear() - Date functions
✓ Slicing [:20] - Limiting results
✓ Chaining - Multiple operations combined

SERIALIZATION COVERAGE:
=======================

✓ NetflixTitleSerializer used in all endpoints
✓ many=True for list endpoints
✓ serializer.is_valid() for validation (Endpoint 2)
✓ serializer.save() for creation (Endpoint 2)
✓ serializer.errors for error handling (Endpoint 2)
✓ serializer.data for JSON output

================================================================================
URL ROUTING PLAN:
================================================================================

File: api/urls.py

```python
from django.urls import path
from . import views

app_name = 'api'

urlpatterns = [
    # Endpoint 1: List all titles with optional filters
    path('titles/', views.title_list, name='title-list'),
    
    # Endpoint 2: Create new title (POST)
    path('titles/create/', views.create_title, name='title-create'),
    
    # Endpoint 3: Get statistics
    path('statistics/', views.get_statistics, name='statistics'),
    
    # Endpoint 4: Advanced search
    path('titles/search/', views.search_titles, name='title-search'),
    
    # Endpoint 5: Get content by country
    path('country/<str:country_name>/', views.country_content, name='country-content'),
    
    # Endpoint 6: Get recommendations
    path('recommendations/', views.get_recommendations, name='recommendations'),
]
```

IMPORTANT: Order matters!
- 'titles/create/' must come before generic 'titles/' patterns
- 'titles/search/' must come before 'titles/<id>/' if you add detail view later

================================================================================
TESTING STRATEGY:
================================================================================

Each endpoint needs unit tests covering:

ENDPOINT 1 Tests:
- Test with no parameters (all titles)
- Test with type filter
- Test with rating filter
- Test with year filter
- Test with multiple filters combined
- Test with invalid parameters

ENDPOINT 2 Tests:
- Test successful creation with all fields
- Test successful creation with required fields only
- Test duplicate show_id rejection
- Test missing required field error
- Test invalid data type error
- Test validation error (e.g., year out of range)

ENDPOINT 3 Tests:
- Test that statistics are returned
- Test type_distribution has correct structure
- Test rating_distribution is ordered correctly
- Test content_by_year contains data
- Test all keys present in response

ENDPOINT 4 Tests:
- Test each filter parameter individually
- Test multiple filters combined
- Test case-insensitive matching
- Test with no results
- Test ordering is correct

ENDPOINT 5 Tests:
- Test with valid country
- Test with invalid/unknown country
- Test statistics are calculated correctly
- Test content list is returned

ENDPOINT 6 Tests:
- Test without required genre parameter (error)
- Test with genre only
- Test with all filters
- Test recent filter logic
- Test result limit (max 20)
- Test with no matching content

================================================================================
WHY THESE ENDPOINTS ARE INTERESTING:
================================================================================

FOR THE REPORT/VIDEO:
--------------------

1. ENDPOINT 1 - Foundation
   "This basic listing endpoint serves as the foundation for content browsing.
   It demonstrates optional query parameters and basic Django filtering, which
   is essential for any content discovery system."

2. ENDPOINT 2 - Data Management
   "This POST endpoint demonstrates content management capabilities. In a real
   Netflix system, this would be used by content managers to add new titles.
   It showcases serializer validation and proper HTTP status codes."

3. ENDPOINT 3 - Business Intelligence
   "This analytics endpoint provides comprehensive statistics about the Netflix
   catalog. It demonstrates advanced aggregation functions and would be useful
   for dashboard visualizations and business intelligence reporting."

4. ENDPOINT 4 - Advanced Discovery
   "This is the most complex endpoint, offering a powerful search system with
   9 different filter options. It demonstrates Q objects and complex boolean
   logic, allowing users to find exactly what they're looking for."

5. ENDPOINT 5 - Geographic Analysis
   "This endpoint enables geographic content analysis, showing what content
   is available from specific countries. This is valuable for understanding
   regional production strategies and content diversity."

6. ENDPOINT 6 - Personalization
   "This recommendation endpoint demonstrates conditional logic and business
   rules. It shows how to implement a basic recommendation system based on
   user preferences, which is core to streaming platform functionality."

BUSINESS VALUE:
--------------
These endpoints collectively enable:
- Content discovery and browsing
- Content management and administration
- Analytics and reporting
- Advanced search capabilities
- Geographic analysis
- Personalized recommendations

TECHNICAL DEMONSTRATION:
-----------------------
These endpoints showcase:
- Django ORM mastery (filtering, aggregation, Q objects)
- RESTful API design principles
- Serializer usage and validation
- Proper HTTP methods and status codes
- Query optimization considerations
- Real-world application patterns

================================================================================
NEXT STEPS:
================================================================================

✓ Step 1.3 COMPLETE - All 6 endpoints designed
→ Step 1.4 NEXT - Development Environment Setup

When implementing (Phase 6):
1. Create serializers.py with NetflixTitleSerializer
2. Create views.py (or api.py) with 6 view functions
3. Create urls.py with URL routing
4. Test each endpoint manually
5. Write unit tests for all endpoints
6. Document in main page with hyperlinks

================================================================================
END OF ENDPOINT DESIGN
================================================================================
